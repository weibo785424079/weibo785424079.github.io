---
title: JS中的位运算
date: 2019-11-07 14:01:52
tags:
---
# 1,内容概要
* JavaScript 的位运算：先简单回顾下位运算，平时用的少，相信不少人和我一样忘的差不多了
* 权限设计：根据位运算的特点，设计一个权限系统（添加、删除、判断等）

# 2.JavaScript 位运算

## 2.1 Number
在讲位运算之前，首先简单看下JavaScript中的Number，下文需要用到

在 JavaScript 里，数字均为基于 IEEE 754 标准的双精度 64 位的浮点数，引用维基百科的图片，它的结构长这样：
![IEEE 754](JS中的位运算/ieee754.png))

## 2.2位运算
按位操作符将其操作数当作 32 位的比特序列（由 0 和 1 组成）操作，返回值依然是标准的 JavaScript 数值。JavaScript 中的按位操作符有：

 | 运算符             | 用法        | 描述                                                                              |
 | ------------------ | ----------- | --------------------------------------------------------------------------------- |
 | 按位与 (AND)       | a & b       | 对于每一个比特位，只有两个操作数相应的特位都是 1 时，结果才为 1，否则为 0。       |
 | 按位或（OR）       | a      \| b | 对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。   |
 | 按位异或（XOR）    | a ^ b       | 对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。 |
 | 按位非（NOT）      | ~a          | 反转操作数的比特位，即 0 变成 1，1 变成 0。                                       |
 | 左移（Left shift） | a << b      | 将 a 的二进制形式向左移 b (< 32) 比特位，右边用 0 填充。                          |
 | 有符号右移         | a >> b      | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。                             |
 | 无符号右移         | a >>> b     | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。        |

### 下面举几个例子，主要看下 AND 和 OR：
```shell
# 例子1
    A = 10001001
    B = 10010000
A | B = 10011001

# 例子2
    A = 10001001
    C = 10001000
A | C = 10001001

```

```shell
# 例子1
    A = 10001001
    B = 10010000
A & B = 10000000

# 例子2
    A = 10001001
    C = 10001000
A & C = 10001000

```

# 3. 位运算在权限系统中的使用

传统的权限系统里，存在很多关联关系，如用户和权限的关联，用户和角色的关联。系统越大，关联关系越多，越难以维护。而引入位运算，可以巧妙的解决该问题。

在讲“位运算在权限系统中的使用”之前，我们先假定两个前提，下文所有的讨论都是基于这两个前提的：
1. 每种权限码都是唯一的（这是显然的）
2. 所有权限码的二进制数形式，有且只有一位值为 1，其余全部为 0（2^n）

#### 如果用户权限和权限码，全部使用二级制数字表示，再结合上面 AND 和 OR 的例子，分析位运算的特点，不难发现：

* | 可以用来赋予权限
* & 可以用来校验权限


#### 为了讲的更明白，这里用 Linux 中的实例分析下，Linux 的文件权限分为读、写和执行，有字母和数字等多种表现形式

| 权限 | 字母表示 | 数字表示 | 二进制 |
| ---- | -------- | -------- | ------ |
| 读   | r        | 4        | 0b100  |
| 写   | w        | 2        | 0b010  |
| 执行 | x        | 1        | 0b001  |

可以看到，权限用 1、2、4（也就是 2^n）表示，转换为二进制后，都是只有一位是 1，其余为 0。我们通过几个例子看下，如何利用二进制的特点执行权限的添加，校验和删除。

## 3.1. 添加权限

```js
let r = 0b100
let w = 0b010
let x = 0b001

// 给用户赋全部权限（使用前面讲的 | 操作）
let user = r | w | x

console.log(user)
// 7

console.log(user.toString(2))
// 111

//     r = 0b100
//     w = 0b010
//     r = 0b001
// r|w|x = 0b111

```

可以看到，执行 r | w | x 后，user 的三位都是 1，表明拥有了全部三个权限。


> Linux 下出现权限问题时，最粗暴的解决方案就是 chmod 777 xxx，这里的 7 就代表了：可读，可写，可执行。而三个 7 分别代表：文件所有者，文件所有者所在 组，所有其他用户。

### 3.3 校验权限
刚才演示了权限的添加，下面演示权限校验：

```js
let r = 0b100
let w = 0b010
let x = 0b001

// 给用户赋 r w 两个权限
let user = r | w
// user = 6
// user = 0b110 (二进制)

console.log((user & r) === r) // true  有 r 权限
console.log((user & w) === w) // true  有 w 权限
console.log((user & x) === x) // false 没有 x 权限
```

如前所料，通过 用户权限 & 权限 code === 权限 code 就可以判断出用户是否拥有该权限。

### 3.3删除权限
我们讲了用 | 赋予权限，使用 & 判断权限，那么删除权限呢？删除权限的本质其实是将指定位置上的 1 重置为 0。上个例子里用户权限是 0b110，拥有读和写两个权限，现在想删除读的权限，本质上就是将第三位的 1 重置为 0，变为 0b010：

```js
let r = 0b100
let w = 0b010
let x = 0b001

let user = 0b010;

console.log((user & r) === r) // false 没有 r 权限
console.log((user & w) === w) // true  有 w 权限
console.log((user & x) === x) // false 没有 x 权限
```

那么具体怎么操作呢？其实有两种方案，最简单的就是异或 ^，按照上文的介绍“当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0”，所以异或其实是 toggle 操作，无则增，有则减：

```js 
let r    = 0b100
let w    = 0b010
let x    = 0b001
let user = 0b110 // 有 r w 两个权限

// 执行异或操作，删除 r 权限
user = user ^ r

console.log((user & r) === r) // false 没有 r 权限
console.log((user & w) === w) // true  有 w 权限
console.log((user & x) === x) // false 没有 x 权限

console.log(user.toString(2)) // 现在 user 是 0b010

// 再执行一次异或操作
user = user ^ r

console.log((user & r) === r) // true  有 r 权限
console.log((user & w) === w) // true  有 w 权限
console.log((user & x) === x) // false 没有 x 权限

console.log(user.toString(2)) // 现在 user 又变回 0b110

```

那么如果单纯的想删除权限（而不是无则增，有则减）怎么办呢？答案是执行 &(~code)，先取反，再执行与操作：

```js

let r    = 0b100
let w    = 0b010
let x    = 0b001
let user = 0b110 // 有 r w 两个权限

// 删除 r 权限
user = user & (~r)

console.log((user & r) === r) // false 没有 r 权限
console.log((user & w) === w) // true  有 w 权限
console.log((user & x) === x) // false 没有 x 权限

console.log(user.toString(2)) // 现在 user 是 0b010

// 再执行一次
user = user & (~r)

console.log((user & r) === r) // false 没有 r 权限
console.log((user & w) === w) // true  有 w 权限
console.log((user & x) === x) // false 没有 x 权限

console.log(user.toString(2)) // 现在 user 还是 0b010，并不会新增
```

# 4. 局限性和解决办法
前面我们回顾了 JavaScript 中的 Number 和位运算，并且了解了基于位运算的权限系统原理和 Linux 文件系统权限的实例。


上述的所有都有前提条件：1、每种权限码都是唯一的；2、每个权限码的二进制数形式，有且只有一位值为 1（2^n）。也就是说，权限码只能是 1, 2, 4, 8,...,1024,...而上文提到，一个数字的范围只能在 -(2^53 -1) 和 2^53 -1 之间，JavaScript 的按位操作符又是将其操作数当作 32 位比特序列的。那么同一个应用下可用的权限数就非常有限了。这也是该方案的局限性。
为了突破这个限制，这里提出一个叫“权限空间”的概念，既然权限数有限，那么不妨就多开辟几个空间来存放。